# ClassLoader

## 类加载过程

![类加载机制](src/main/resources/pic/class_loader_01.png "类加载机制")

* 加载(loading)  
    查找并加载二进制数据
* 链接(linking)  
    * 验证(verifying)  
        确保被加载类的正确性
    * 准备(preparing)  
        为类的静态变量分配内存，并将其初始化为默认值
    * 解析(resolving)  
        把类中的符号引用转换为直接引用
* 初始化(initialising)  
    为类的静态变量赋予正确的初始值
    
所有的java虚拟机实现必须在每个类或者每个接口被java程序首次主动使用时才初始化他们，当然现代jvm有可能根据程序上下文语义推断出接下来可能初始化谁

* 主动使用

    * new 直接使用
    * 访问某个类或者接口的静态变量，或者对该静态变量进行赋值操作
    * 调用静态方法
    * 反射某个类
    * 初始化一个子类
    * 启动类 java HelloWord

* 被动使用

    * 除了上面的都是被动使用

## 类加载阶段介绍

类加载简单来说，就是将class文件中的二进制数据读取到内存中，将其放在方法区，
然后在堆区创建一个java.lang.Class对象，用来封装在方法区的数据结构

## 类加载最终产物

**类加载的最终产品是位于堆区的class对象**

## 类加载方式

* 本地磁盘中直接加载
* 内存中直接加载
* 通过网络加载.class
* 从zip，jar等归档文件中加载
* 数据库中提取.class
* 动态编译

## 三大阶段详解

### 1.加载阶段发生的故事

加载阶段完成后，虚拟机外部的二级制数据就会按照虚拟机所需要的格式存储在方法区（数据结构），
然后在堆内存中创建一个Class对象，这个对象作为程序访问方法区这些数据结构的
外部接口。

* Jvm内存结构

![Jvm内存结构](src/main/resources/pic/class_loader_04.png "Jvm内存结构")

* 对象存在方式

![对象存在方式](src/main/resources/pic/class_loader_02.png "对象存在方式")

* 对象访问方式

![对象访问方式](src/main/resources/pic/class_loader_03.png "对象访问方式")

### 2.链接阶段发生的故事

加载阶段和链接阶段是可以交叉进行的，比如一部分代码加载完成就可以进行验证，提高效率

#### 1)验证

验证主要目的是确保class文件中的字节流包含的信息符合虚拟机的要求，并且不会损坏JVM自身的安全

验证出错：VerifyError

文件格式验证：
* 魔术因子是否正确，0xCAFEBABE
* 主版本号是否符合当前虚拟机
* 常量池中的常量类型是不是不支持 

元数据验证：
* 是否有父类
* 父类是不是允许继承
* 是否实现了抽象方法
* 是否覆盖了父类的final字段
* 其他语义检查

字节码验证：
* 主要进行数据流和控制流分析，不会出现这样的情况，在操作栈中放一个int类型，
但是却给了一个long类型的数据

符号引用：
* 调用一个不存在方法字段等

#### 2)准备

给类**静态**变量分配初始值
* int               ---------------->0  
* long              -------------->0L  
* short             ------------->(short)0  
* char              -------------->'\u0000'  
* byte              -------------->(byte)0  
* boolean           --------->false  
* float             -------------->0.0f  
* double            ----------->0.0d  
* reference         -------->null  

#### 3)解析

符号引用转直接引用

* 类或者接口解析
* 字段解析
* 类方法解析
* 接口方法解析

### 3.初始化过程发生的故事

* 初始化阶段是执行构造函数\<clinit>()方法的过程

* \<clinit>()方法是由编译器自动收集类中所有变量的赋值动作和静态语句块合并产生的。

* 静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，只能赋值不能访问

* \<clinit>()方法与类的构造函数有点区别，它不需要显式调用父类的构造函数，
虚拟机会保证在子类的\<clinit>()方法执行前，先执行父类的\<clinit>()方法，因此在虚拟机中
首先被执行的是Object的\<clinit>()方法

* 由于父类的\<clinit>()方法优先性，也就意味着父类中的静态语句块，要优先于子类

* \<clinit>()方法对于一个类不是必须的

* 接口中照样存在\<clinit>()方法

* 虚拟机有义务保证\<clinit>()方法的线程安全
~~~
static {
        a = 20;
    }
private static int a = 2;
//结果a = 2
分析：
加载阶段给a分配内存
准备阶段给a赋值默认值为0 //a = 0
初始化阶段先执行静态代码块 //a = 20
然后往下执行给a赋真实值 //a = 2
~~~








    


