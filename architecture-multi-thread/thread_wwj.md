# JavaMultiThread
### Java多线程教程笔记

[Jvm虚拟机知识点讲解](../jvm-learn/jvm.md)

---
### 并发编程三个重要概念

1.原子性  
* 一个或者多个操作，要么都成功，要么都失败，中间不能有任何中断  

2.可见性  
* 共享变量可以被所有线程可见  

3.有序性  
* 禁止对指令进行优化重排序  
重排序：只要求最终一致性

### 线程名
Thread+递增的数字
如果不传入名字会调用nextThreadNum()的同步方法，对静态变量threadInitNumber++

### 线程组
如果构造线程对象时候，没有传入ThreadGroup,会默认获取父线程的ThreadGroup作为自己的，此时子线程和父线程会在同一个ThreadGroup中

### ThreadSize
构建线程的时候传入这个值，代表着该线程占用的stack大小<br>
如果没有指定这个值，则默认为0,0代表会忽略这个参数，该参数会被JNI函数去使用<br>
注意：该参数在一些平台有效，一些无效

### 守护线程：DaemonThread
将线程设置为守护线程，则会随着创建自己的线程的结束而结束<br>
t.setDaemon(true);<br>
注意：守护线程是随着创建自己的父线程一起结束<br>
**线程组设置为守护线程**：<br>
当线程组中最后一个线程结束时候，整个线程组销毁<br>

### 线程优先级
1-10 10为最大，普通优先级为5<br>
尽量优先最大优先级的线程执行，但是不保证<br>

### Thread Join
等待其他线程执行完<br>
join:当前线程需要等我这个线程结束再执行下面的任务

### ThreadInterrupt
线程中断<br/>
 -interrupted()<br/>
 -静态方法，获得线程中断标识后会将中断标识清除 <br/>
 -isInterrupted() <br/>
 -只会获得线程是否中断，不会清除中断标识 <br/>

  真正优雅的停止线程：先设置中断标志，在程序中检测中断标志，并主动停止任务

### Synchronized 
同步方法:使用的this锁<br/>
同步方法块:使用的对象锁<br/>
this锁:<br/>
对于对象锁（this），如果是同一个实例，就会按顺序访问，但是如果是不同实例，就可以同时访问。<br/>
class锁:<br/>
静态锁，锁的是类的字节码信息等同于synchronized (ThreadSynchronizedStatic.class)
只要采用类锁，就会拦截所有线程，只能让一个线程访问。<br/>

### Wait Notify

* wait：等待锁资源，需要被其他线程唤醒（或者自己设置超时时间）
* notify：唤醒一个等待这个锁的线程
* notifyAll：唤醒所有等待这个锁的线程

**sleep和wait的区别？**

1. sleep是Thread的方法，wait是Object的方法
2. sleep不会释放锁，wait会释放锁并加入对象等待队列
3. sleep不依赖锁，但是wait必须在synchronized里面
4. sleep不需要被唤醒，但是wait需要被其他线程唤醒

### Volatile关键字

#### Java内存模型:  
规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。
由于java中的每个线程有自己的工作空间，这种工作空间相当于上面所说的高速缓存，因此多个线程在处理一个共享变量的时候，就会出现线程安全问题。

##### 共享变量:  
上面我们所说的t就是一个共享变量，也就是说，能够被多个线程访问到的变量，我们称之为共享变量。在java中共享变量包括实例变量，静态变量，数组元素。他们都被存放在堆内存中。

#### 线程可见性:

在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取。

#### cpu真实模型：

![CPU数据交换模型](./src/main/resources/pic/cpu_cache.png "CPU数据交换模型")  

cpu--->高速缓存 

产生问题：缓存不一致？  
解决：缓存一致性协议

#### 发生场景：
int i = i + 1  
* cpu缓存i放入高速缓存cache中  
* 计算i+1结果放入高速缓存cache中  
* 将cache中的i的值写入主内存main memory

cpu1-> main memory->i(1)->cache i+1->cache(2)->main memory(2)  
cpu2-> main memory->i(1)->cache i+1->cache(2)->main memory(2)

当多核cpu执行的时候，每个线程占用一个cpu，每个cpu有自己的高速缓存，同时执行上面的操作，都在自己的高速缓存中操作i，最后写入主内存，则会可能出现缓存不一致导致的线程安全问题。

#### 解决缓存一致性问题：

1.给数据总线加锁，lock，导致多核cpu处理效率低下  
2.cpu高速缓存一致性协议  
**核心思想：**  
* 当cpu写入数据的时候，如果发现该变量被共享（也就是在其他cpu中也存在该变量副本），会发出一个信号通知其他cpu该变量无效
* 当其他cpu访问该变量时候，重新去主内存读取



































































  
